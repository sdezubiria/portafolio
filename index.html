<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Portafolio - Simón</title>
    <link rel="stylesheet" href="style.css" />
    <!-- Add Work Sans and Roboto Mono from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Work+Sans:ital,wght@0,100..900;1,100..900&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>
    <div id="intro-animation">
      <!-- Panels that animate outwards -->
      <div class="panel blue"></div>
      <div class="panel black"></div>
      <div class="panel white"></div>
      <div class="panel blue"></div>
      <div class="panel black"></div>
      <div class="panel white"></div>
    </div>

    <!-- Background grid container -->
    <div id="background-grid"></div>

    <main class="hidden">
      <header class="header">
        <div>
          <h1>Simón De Zubiría Restrepo</h1>
          <p>Diseñador y desarrollador web</p>
          <p>
            Me interesa profundamente la programación como una herramienta para
            crear experiencias visuales significativas, impactantes y
            técnicamente refinadas. Considero el código no solo como un lenguaje
            funcional, sino como un medio creativo con el potencial de generar
            conexiones auténticas a través del arte, la interacción y el diseño.
            Poseo una sensibilidad estética desarrollada y un fuerte impulso
            hacia la creación en todas sus formas. Mis intereses abarcan el
            desarrollo visual con código, el diseño gráfico, la animación, la
            ilustración, el 3D y las experiencias interactivas.
          </p>
          <a href="CVSimon.pdf" class="button" download>Descargar CV</a>
          <div>
        <h1>Proyectos</h1>
          </div>
  
        </div>
      </header>

      <section class="proyectos">
        <div class="grid">
          <a href="proyecto1.html" class="card">
            <img src="p1.jpg" alt="Imagen de Proyecto 1" />
            <h3>Oscilaciones</h3>
            <p>Una exploración metamodernista del amor</p>
          </a>
          <a href="proyecto2.html" class="card">
            <img src="p2.jpg" alt="Imagen de Proyecto 2" />
            <h3>Portfolio Path</h3>
            <p>Diseño web y branding para una marca de asesoría de arte</p>
          </a>
          <a href="proyecto3.html" class="card">
            <img src="p3.jpg" alt="Imagen de Proyecto 3" />
            <h3>The Doubtful Guest</h3>
            <p>Proyecto Web narrativo</p>
          </a>
          <a href="proyecto4.html" class="card">
            <img src="p4.jpg" alt="Imagen de Proyecto 4" />
            <h3>LabJusticia</h3>
            <p>
              Desarrollo de la página del laboratorio para la justica Uniandes
            </p>
          </a>
          <a href="proyecto5.html" class="card">
            <img src="p5.jpg" alt="Imagen de Proyecto 5" />
            <h3>Galería visual y audiovisual</h3>
            <p>
              Colección de imágenes y videos que muestran otras facetas mías
            </p>
          </a>
        </div>
      </section>
    </main>

    <script>
      // Create the background grid immediately
      const gridContainer = document.createElement("div");
      gridContainer.id = "background-grid";
      document.body.appendChild(gridContainer);

      // Grid state management
      let gridState = [];
      let animationId;
      let currentGrid = { columns: 10, rows: 10 };

      // Cell class to manage individual cell behavior
      class GridCell {
        constructor(
          startCol,
          startRow,
          initialColSpan,
          initialRowSpan,
          maxColSpan,
          maxRowSpan
        ) {
          this.startCol = startCol;
          this.startRow = startRow;
          this.currentColSpan = initialColSpan;
          this.currentRowSpan = initialRowSpan;
          this.targetColSpan = initialColSpan;
          this.targetRowSpan = initialRowSpan;
          this.maxColSpan = maxColSpan;
          this.maxRowSpan = maxRowSpan;
          this.animationPhase = Math.random() * Math.PI * 2;
          this.spanChangeTimer = Math.random() * 3000 + 2000; // 2-5 seconds
          this.lastSpanChange = Date.now();

          // Create DOM element
          this.element = document.createElement("div");
          this.element.style.transition =
            "all 1.2s cubic-bezier(0.4, 0, 0.2, 1)";
          this.updatePosition();
          gridContainer.appendChild(this.element);
        }

        updatePosition() {
          this.element.style.gridColumn = `${
            this.startCol + 1
          } / span ${Math.round(this.currentColSpan)}`;
          this.element.style.gridRow = `${
            this.startRow + 1
          } / span ${Math.round(this.currentRowSpan)}`;
        }

        updateSpans(deltaTime) {
          // Smoothly interpolate toward target spans
          const lerpSpeed = 0.03;
          this.currentColSpan +=
            (this.targetColSpan - this.currentColSpan) * lerpSpeed;
          this.currentRowSpan +=
            (this.targetRowSpan - this.currentRowSpan) * lerpSpeed;

          // Check if it's time to change target spans
          const now = Date.now();
          if (now - this.lastSpanChange > this.spanChangeTimer) {
            this.chooseNewTargetSpans();
            this.lastSpanChange = now;
            this.spanChangeTimer = Math.random() * 4000 + 3000; // 3-7 seconds
          }

          this.updatePosition();
        }

        chooseNewTargetSpans() {
          // Randomly choose new target spans within limits
          this.targetColSpan = Math.floor(Math.random() * this.maxColSpan) + 1;
          this.targetRowSpan = Math.floor(Math.random() * this.maxRowSpan) + 1;
        }

        animate(time) {
          const cellTime = time + this.animationPhase;

          // Subtle pulsing effect
          const opacity = 0.4 + 0.2 * Math.sin(cellTime * 0.8);
          this.element.style.opacity = opacity;

          // Subtle color animation
          const hue =
            (time * 10 + this.startCol * 30 + this.startRow * 20) % 360;
          const saturation = 15 + 10 * Math.sin(cellTime * 0.5);
          const lightness = 88 + 8 * Math.cos(cellTime * 0.3);
          this.element.style.backgroundColor = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.15)`;
        }

        destroy() {
          this.element.remove();
        }
      }

      // Function to calculate non-overlapping cell layout
      function calculateCellLayout(columns, rows) {
        const cells = [];
        const occupied = Array(rows)
          .fill()
          .map(() => Array(columns).fill(false));

        let attempts = 0;
        const maxAttempts = columns * rows;

        while (attempts < maxAttempts) {
          attempts++;

          // Find next available position
          let startRow = -1,
            startCol = -1;
          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < columns; c++) {
              if (!occupied[r][c]) {
                startRow = r;
                startCol = c;
                break;
              }
            }
            if (startRow !== -1) break;
          }

          if (startRow === -1) break;

          // Calculate maximum possible spans
          let maxColSpan = Math.min(columns - startCol, 3); // Limit spans to 3
          let maxRowSpan = Math.min(rows - startRow, 3); // Limit spans to 3

          // Choose initial span
          const initialColSpan = Math.floor(Math.random() * maxColSpan) + 1;
          const initialRowSpan = Math.floor(Math.random() * maxRowSpan) + 1;

          // Create cell
          const cell = new GridCell(
            startCol,
            startRow,
            initialColSpan,
            initialRowSpan,
            maxColSpan,
            maxRowSpan
          );
          cells.push(cell);

          // Mark area as occupied
          for (let r = startRow; r < startRow + initialRowSpan; r++) {
            for (let c = startCol; c < startCol + initialColSpan; c++) {
              occupied[r][c] = true;
            }
          }
        }

        return cells;
      }

      // Function to regenerate grid with smooth transitions
      function regenerateGrid() {
        // Use DocumentFragment for batch DOM updates
        const fragment = document.createDocumentFragment();

        // Clear existing cells
        gridState.forEach((cell) => cell.destroy());

        // Generate new layout
        gridState = calculateCellLayout(currentGrid.columns, currentGrid.rows);

        // Create new cells and append them in a single operation
        gridState.forEach((cell) => fragment.appendChild(cell.element));

        // Update grid template and append cells
        gridContainer.style.gridTemplateColumns = `repeat(${currentGrid.columns}, 1fr)`;
        gridContainer.style.gridTemplateRows = `repeat(${currentGrid.rows}, 1fr)`;
        gridContainer.appendChild(fragment);
      }

      // Main animation loop
      function animate() {
        const time = Date.now() * 0.0001;

        // Update all cells
        gridState.forEach((cell) => {
          cell.updateSpans();
          cell.animate(time);
        });

        // Occasionally change grid dimensions (throttled)
        if (Math.random() < 0.001) {
          // Increase probability slightly
          const newColumns = Math.floor(Math.random() * 8) + 6; // 6-14
          const newRows = Math.floor(Math.random() * 8) + 6; // 6-14

          if (
            newColumns !== currentGrid.columns ||
            newRows !== currentGrid.rows
          ) {
            currentGrid.columns = newColumns;
            currentGrid.rows = newRows;
            regenerateGrid();
          }
        }

        animationId = requestAnimationFrame(animate);
      }

      // Initialize
      regenerateGrid();
      animate();

      // Performance optimization
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          if (animationId) cancelAnimationFrame(animationId);
        } else {
          animate();
        }
      });

      // Animar y luego mostrar contenido
      window.addEventListener("load", () => {
        const panels = document.querySelectorAll(".panel");
        const introAnimation = document.querySelector("#intro-animation");
        const mainContent = document.querySelector("main");

        // Ensure panels animate out one by one
        panels.forEach((panel, i) => {
          setTimeout(() => {
            panel.classList.add("out");
          }, i * 200); // Reduce delay to 200ms for faster animation
        });

        // Wait for all panels to finish animating before showing main content
        const totalAnimationTime = panels.length * 200 + 500; // Adjust total time
        setTimeout(() => {
          introAnimation.classList.add("hidden"); // Smooth fade-out effect
          setTimeout(() => {
            mainContent.classList.remove("hidden"); // Show main content
          }, 500); // Wait for fade-out to complete
        }, totalAnimationTime);
      });
    </script>
  </body>
</html>
